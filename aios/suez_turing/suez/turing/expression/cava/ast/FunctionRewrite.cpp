/*
 * Copyright 2014-present Alibaba Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "suez/turing/expression/cava/ast/FunctionRewrite.h"

#include <cstddef>
#include <vector>

#include "alog/Logger.h"
#include "cava/ast/ASTContext.h"
#include "cava/ast/ASTNode.h"
#include "cava/ast/AmbExpr.h"
#include "cava/ast/AmbTypeNode.h"
#include "cava/ast/AssignExpr.h"
#include "cava/ast/CallExpr.h"
#include "cava/ast/CanonicalTypeNode.h"
#include "cava/ast/ClassBodyDecl.h"
#include "cava/ast/ClassDecl.h"
#include "cava/ast/ExprStmt.h"
#include "cava/ast/Formal.h"
#include "cava/ast/LiteralExpr.h"
#include "cava/ast/LocalVarDeclStmt.h"
#include "cava/ast/MethodDecl.h"
#include "cava/ast/Modifier.h"
#include "cava/ast/NodeFactory.h"
#include "cava/ast/ReturnStmt.h"
#include "cava/ast/TypeNode.h"
#include "cava/common/Common.h"
#include "suez/turing/expression/cava/common/CavaASTUtil.h"

namespace cava {
class CompoundStmt;
class FieldDecl;
class Name;
class VarDecl;
} // namespace cava

using namespace std;
using namespace cava;

namespace suez {
namespace turing {
AUTIL_LOG_SETUP(ast, FunctionRewrite);
EXPORT_PLUGIN_CREATOR(ASTRewriter, FunctionRewrite);

std::unordered_map<std::string, std::string> FunctionRewrite::Type2MethodName = {
    {"byte", "getInt8"},     {"short", "getInt16"},     {"int", "getInt32"},       {"long", "getInt64"},
    {"ubyte", "getUInt8"},   {"ushort", "getUInt16"},   {"uint", "getUInt32"},     {"ulong", "getUInt64"},
    {"MInt8", "getMInt8"},   {"MInt16", "getMInt16"},   {"MInt32", "getMInt32"},   {"MInt64", "getMInt64"},
    {"MUInt8", "getMUInt8"}, {"MUInt16", "getMUInt16"}, {"MUInt32", "getMUInt32"}, {"MUInt64", "getMUInt64"},
    {"float", "getFloat"},   {"double", "getDouble"},   {"MFloat", "getMFloat"},   {"MDouble", "getMDouble"},
    {"MChar", "getMChar"},   {"MString", "getMString"}, {"boolean", "getBoolean"},
};

/*
class demo {
    private ha3.MDouble ratios_inner_process_MDouble; //generated by addClassFields
    double inner_process_MDouble(MatchDoc doc, ExpressionVector args) // generated by addNewMethods
    {
        ratios_inner_process_MDouble = args.get(0).getMDouble(doc, ratios_inner_process_MDouble);
        int id;
        id = args.get(1).getInt32(doc);
        return process(doc, ratios_inner_process_MDouble, id);
    }
    double process(MatchDoc doc, ha3.MDouble ratios, int id);
}

 */
bool FunctionRewrite::addClassFields(const std::string &newMethodName) {
    Location loc;
    Modifier *modifier = NodeFactory::createModifier(*_astCtx, loc);
    modifier->setFlag(::cava::Modifier::F_PRIVATE);

    std::vector<Formal *> &formals = _methodDecl->getFormals();
    for (size_t i = 1; i < formals.size(); ++i) {
        TypeNode *type = formals[i]->getTypeNode();
        if (type->getKind() == ::cava::AmbTypeNode::TNK_Amb) {
            AmbTypeNode *ambType = static_cast<AmbTypeNode *>(type);
            const std::string &formalName = formals[i]->getFormalName(); //参数名
            std::string *newFieldName = _astCtx->allocString(formalName + CAVA_INNER_METHOD_SEP + newMethodName);
            VarDecl *varDecl = NodeFactory::createVarDecl(*_astCtx, loc, newFieldName);
            FieldDecl *fieldDecl = NodeFactory::createFieldDecl(*_astCtx, loc, modifier, ambType, varDecl);
            _classDecl->getClassBodyDecl()->addField(fieldDecl);
        }
    }

    return true;
}
bool FunctionRewrite::addNewMethods(const std::string &newMethodName) {
    Location loc;
    std::vector<Formal *> &formals = _methodDecl->getFormals();

    //构建 retType inner_process_...(MatchDoc doc, unsafe.ExpressionVector args)
    std::vector<Formal *> *newFormals = _astCtx->allocFormalVec();
    newFormals->push_back(formals[0]); // MatchDoc doc

    Name *package = NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString("unsafe"));
    Name *fullClassName = NodeFactory::createName(*_astCtx, loc, package, _astCtx->allocString("ExpressionVector"));
    AmbTypeNode *typeNode = NodeFactory::createAmbTypeNode(*_astCtx, loc, fullClassName);
    VarDecl *varDecl = NodeFactory::createVarDecl(*_astCtx, loc, _astCtx->allocString("args"));
    Formal *formal = NodeFactory::createFormal(*_astCtx, loc, typeNode, varDecl);
    newFormals->push_back(formal); // unsafe.ExpressionVector args
    MethodDecl *newMethodDecl = NodeFactory::createMethodDecl(*_astCtx,
                                                              loc,
                                                              _methodDecl->getModifier(),
                                                              _astCtx->allocString(newMethodName),
                                                              newFormals,
                                                              _methodDecl->getRetType());

    //构建函数体
    AmbExpr *argsExpr = NodeFactory::createAmbExpr(
        *_astCtx, loc, NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString("args")));
    auto methodBodyStmtVec = _astCtx->allocStmtVec();

    auto argsExprVec = _astCtx->allocExprVec(); //调用原始process的参数数组
    AmbExpr *matchDoc = NodeFactory::createAmbExpr(
        *_astCtx, loc, NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString(formals[0]->getFormalName())));
    argsExprVec->push_back(matchDoc); //第一个MatchDoc变量 doc

    for (size_t i = 1; i < formals.size(); ++i) {
        TypeNode *type = formals[i]->getTypeNode();           //参数类型
        std::string formalName = formals[i]->getFormalName(); //参数名

        auto callGetXXArgs = _astCtx->allocExprVec();
        callGetXXArgs->push_back(matchDoc);
        std::string typeName;
        AmbExpr *assignLeftExpr = NULL;
        if (type->getKind() == ::cava::TypeNode::TNK_Canonical ||
            (type->getKind() == ::cava::TypeNode::TNK_Amb && ((AmbTypeNode *)type)->getClassName() == "MChar")) {
            LocalVarDeclStmt *localVar =
                NodeFactory::createLocalVarDeclStmt(*_astCtx, loc, type, formals[i]->getVarDecl());
            methodBodyStmtVec->push_back(localVar); // 普通类型的变量声明:int id

            assignLeftExpr = NodeFactory::createAmbExpr(
                *_astCtx, loc, NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString(formalName)));

            CanonicalTypeNode *castType = static_cast<CanonicalTypeNode *>(type);
            typeName = castType->toString();

        } else {
            formalName += CAVA_INNER_METHOD_SEP + newMethodName;
            assignLeftExpr = NodeFactory::createAmbExpr(
                *_astCtx, loc, NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString(formalName)));
            callGetXXArgs->push_back(assignLeftExpr); //只有多值有 getMDouble(doc, ratios_inner_process_MDouble);
            AmbTypeNode *castType = static_cast<AmbTypeNode *>(type);
            typeName = castType->getClassName();
        }

        auto getExprVec = _astCtx->allocExprVec();
        getExprVec->push_back(NodeFactory::createTypedLiteralExpr<int>(*_astCtx, loc, LiteralExpr::LT_INT, i - 1));
        CallExpr *getArgsExpr = NodeFactory::createCallExpr(
            *_astCtx, loc, argsExpr, _astCtx->allocString("get"), getExprVec); // args.get(i-1)
        CallExpr *rightExpr = NodeFactory::createCallExpr(*_astCtx,
                                                          loc,
                                                          getArgsExpr,
                                                          _astCtx->allocString(Type2MethodName[typeName]),
                                                          callGetXXArgs); // args.get(i).getInt32(doc)

        AssignExpr *assignExpr =
            NodeFactory::createAssignExpr(*_astCtx, loc, assignLeftExpr, ::cava::AssignExpr::AT_EQ, rightExpr);
        methodBodyStmtVec->push_back(NodeFactory::createExprStmt(*_astCtx, loc, assignExpr));

        AmbExpr *arg = NodeFactory::createAmbExpr(
            *_astCtx, loc, NodeFactory::createName(*_astCtx, loc, NULL, _astCtx->allocString(formalName)));
        argsExprVec->push_back(arg);
    }

    CallExpr *returnExpr =
        NodeFactory::createCallExpr(*_astCtx, loc, NULL, _astCtx->allocString("process"), argsExprVec);
    auto returnStmt = NodeFactory::createReturnStmt(*_astCtx, loc, returnExpr);
    methodBodyStmtVec->push_back(returnStmt);
    CompoundStmt *body = NodeFactory::createCompoundStmt(*_astCtx, loc, methodBodyStmtVec);
    newMethodDecl->setBody(body);
    _classDecl->getClassBodyDecl()->addMethod(newMethodDecl);
    return true;
}

bool FunctionRewrite::matchProcess(::cava::MethodDecl *methodDecl) {
    if ("process" != methodDecl->getMethodName()) {
        return false;
    }
    if (methodDecl->getModifier()->isStatic() || methodDecl->getModifier()->isPrivate()) {
        return false;
    }
    auto &formals = methodDecl->getFormals();
    if (formals.size() < 1) {
        return false;
    }

    TypeNode *type = formals[0]->getTypeNode();
    if (::cava::TypeNode::TNK_Amb != type->getKind()) {
        return false;
    }
    AmbTypeNode *ambType = static_cast<AmbTypeNode *>(type);
    if ("MatchDoc" != ambType->getClassName()) { //不带package的className
        return false;
    }

    //只支持buildin类型和自定义的多值类型,
    //这里有漏洞, ast阶段类型看不到是哪里的package!
    for (size_t i = 1; i < formals.size(); ++i) {
        TypeNode *type = formals[i]->getTypeNode();
        if (type->getKind() == ::cava::AmbTypeNode::TNK_Array || type->getKind() == ::cava::AmbTypeNode::TNK_None) {
            return false;
        }

        std::string typeName;
        if (type->getKind() == ::cava::AmbTypeNode::TNK_Amb) {
            typeName = static_cast<AmbTypeNode *>(type)->getClassName();
        } else if (type->getKind() == ::cava::AmbTypeNode::TNK_Canonical) {
            typeName = static_cast<CanonicalTypeNode *>(type)->toString();
        }
        auto it = Type2MethodName.find(typeName);
        if (it == Type2MethodName.end()) {
            AUTIL_LOG(ERROR, "not support type :%s", typeName.c_str());
            return false;
        }
    }

    return true;
}

bool FunctionRewrite::needRewriteClass(::cava::ClassDecl *classDecl) {
    //如果已经存在inner_process函数,则不改写
    bool needRewrite = true;
    for (auto methodDecl : classDecl->getMethods()) {
        if (methodDecl->getMethodName().find(CAVA_INNER_METHOD_NAME) == 0) {
            AUTIL_LOG(
                WARN, "%s already exists, no rewriting :%s", CAVA_INNER_METHOD_NAME, classDecl->getClassName().c_str());
            needRewrite = false;
        }
    }
    return needRewrite;
}

bool FunctionRewrite::process(ASTContext &astCtx) {
    _astCtx = &astCtx;
    for (auto classDecl : astCtx.getClassDecls()) {
        if (!CavaASTUtil::functionMatcher(classDecl)) {
            continue;
        }
        if (!needRewriteClass(classDecl)) {
            continue;
        }
        _classDecl = classDecl;

        std::vector<MethodDecl *> allMethods = classDecl->getMethods();
        for (size_t i = 0; i < allMethods.size(); ++i) {
            auto &methodDecl = allMethods[i];
            if (!matchProcess(methodDecl)) {
                continue;
            }
            _methodDecl = methodDecl;
            std::string newMethodName = CAVA_INNER_METHOD_NAME;
            auto &formals = _methodDecl->getFormals();
            for (size_t i = 1; i < formals.size(); ++i) {
                TypeNode *type = formals[i]->getTypeNode();
                if (type->getKind() == ::cava::AmbTypeNode::TNK_Canonical) {
                    newMethodName += CAVA_INNER_METHOD_SEP + static_cast<CanonicalTypeNode *>(type)->toString();
                } else if (type->getKind() == ::cava::AmbTypeNode::TNK_Amb) {
                    newMethodName += CAVA_INNER_METHOD_SEP + static_cast<AmbTypeNode *>(type)->getClassName();
                }
            }

            addClassFields(newMethodName);
            addNewMethods(newMethodName);
        }
        AUTIL_LOG(DEBUG, "class %s, rewrited : [%s]", classDecl->getClassName().c_str(), classDecl->toString().c_str());
    }
    return true;
}

} // namespace turing
} // namespace suez
