#include "FakeAsyncTodoRunner.h"

#include "autil/Log.h"

namespace suez {
AUTIL_DECLARE_AND_SETUP_LOGGER(suez, FakeAsyncTodoRunner);

FakeAsyncTodoRunner::FakeAsyncTodoRunner(autil::ThreadPool *threadPool, const std::string &name)
    : TodoRunner(name), _threadPool(threadPool), _stopRunner(false) {}

FakeAsyncTodoRunner::~FakeAsyncTodoRunner() {}

bool FakeAsyncTodoRunner::isOngoing(const std::string &identifier) const {
    autil::ScopedLock lock(_mutex);
    return _ongoingFlagMap.find(identifier) != _ongoingFlagMap.end();
}

bool FakeAsyncTodoRunner::markOngoing(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    if (_ongoingFlagMap.find(identifier) == _ongoingFlagMap.end()) {
        _ongoingFlagMap[identifier] = false;
        _finishFlagMap[identifier] = false;
        return true;
    } else {
        return false;
    }
}

void FakeAsyncTodoRunner::remove(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    _ongoingFlagMap.erase(identifier);
    _finishFlagMap.erase(identifier);
}

bool FakeAsyncTodoRunner::checkStart(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    return _ongoingFlagMap[identifier];
}

void FakeAsyncTodoRunner::setStart(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    _ongoingFlagMap[identifier] = true;
}

bool FakeAsyncTodoRunner::checkFinished(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    return _finishFlagMap[identifier];
}

void FakeAsyncTodoRunner::setFinished(const std::string &identifier) {
    autil::ScopedLock lock(_mutex);
    _finishFlagMap[identifier] = true;
}

void FakeAsyncTodoRunner::stopAll() {
    autil::ScopedLock lock(_mutex);
    _stopRunner = true;
    usleep(10 * 1000);
}

bool FakeAsyncTodoRunner::run(const std::shared_ptr<Todo> &todo) {
    const auto &identifier = todo->getIdentifier();
    if (!markOngoing(identifier)) {
        AUTIL_LOG(INFO,
                  "todo [%s:%s] generated by last decision loop is still waiting to run",
                  todo->getIdentifier().c_str(),
                  opName(todo->getType()));
        return false;
    }
    AUTIL_LOG(INFO, "ongoing [%s:%s]", todo->getIdentifier().c_str(), opName(todo->getType()));

    auto fn = [this, todo, identifier]() {
        while (!checkStart(identifier)) {
            if (_stopRunner) {
                return;
            }
            usleep(1000);
        }
        todo->run();
        setFinished(identifier);
    };

    auto ret = _threadPool->pushTask(std::move(fn), false);
    if (ret != autil::ThreadPool::ERROR_NONE) {
        remove(identifier);
        return false;
    }
    return true;
}

bool FakeAsyncTodoRunner::finishAsyncTask(PartitionId &pid) {
    auto identifier = FastToJsonString(pid, true);
    if (!isOngoing(identifier)) {
        return false;
    }
    setStart(identifier);
    while (!checkFinished(identifier)) {
        usleep(1000);
    }
    remove(identifier);
    return true;
}

} // namespace suez
