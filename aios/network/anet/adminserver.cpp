/*
 * Copyright 2014-present Alibaba Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "aios/network/anet/adminserver.h"

#include <iosfwd>
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <syscall.h>
#include <unistd.h>

#include "aios/network/anet/addrspec.h"
#include "aios/network/anet/admincmds.h"
#include "aios/network/anet/anet.h"
#include "aios/network/anet/connection.h"
#include "aios/network/anet/controlpacket.h"
#include "aios/network/anet/defaultpacketstreamer.h"
#include "aios/network/anet/ilogger.h"
#include "aios/network/anet/iocomponent.h"
#include "aios/network/anet/log.h"
#include "aios/network/anet/packet.h"
#include "aios/network/anet/stats.h"
#include "aios/network/anet/thread.h"

using namespace std;
BEGIN_ANET_NS();

pid_t gettid() { return syscall(SYS_gettid); }

void AdminServer::runInThread() {
    _threadCreated = true;
    _thread.start(this, NULL);
}

void AdminServer::run(Thread *thread, void *arg) { start(); }

void AdminServer::start() {

    AdvanceDefaultPacketFactory factory;
    DefaultPacketStreamer streamer(&factory);
    /* remember if we create domain socket file to listen. */
    bool sockFileExist = false;
    char path[MAX_PATH_LEN];
    char spec[MAX_PATH_LEN];

    _pid = getpid();

    if (_spec == "") {
        snprintf(path, MAX_PATH_LEN, "%s%s%d", DOMAIN_SOCK_PATH, ADMIN_FILE_PREFIX, getpid());
        path[MAX_PATH_LEN - 1] = '\0';
        snprintf(spec, MAX_PATH_LEN, "%s%s", "unixstream:", path);
        spec[MAX_PATH_LEN - 1] = '\0';
        _spec.assign(spec);
        sockFileExist = true;
    }

    IOComponent *ioc = _transport.listen(_spec.c_str(), &streamer, this);
    if (ioc == NULL) {
        ANET_LOG(ERROR, "listen error.");
        return;
    }
    ANET_LOG(INFO, "AdminServer(%s) started.", _spec.c_str());
    _transport.run();
    ANET_LOG(INFO, "AdminServer(%s) Quiting...", _spec.c_str());
    ANET_GLOBAL_STAT.log();
    ioc->close();
    ioc->subRef();
    /* clean up domain socket file if it is generated by us. */
    if (sockFileExist) {
        unlink(path);
    }
}

IPacketHandler::HPRetCode AdminServer::handlePacket(Connection *connection, Packet *packet) {
    if (!packet->isRegularPacket()) {
        ANET_LOG(WARN,
                 "=> ControlPacket: %d, What: %s",
                 ((ControlPacket *)packet)->getCommand(),
                 ((ControlPacket *)packet)->what());
        packet->free();
        return IPacketHandler::FREE_CHANNEL;
    }

    /* extracting command string from message body. */
    AdvanceDefaultPacket *advPacket = dynamic_cast<AdvanceDefaultPacket *>(packet);
    char *body = advPacket->getBody();
    int len = advPacket->getBodyLen();

    if (len > MAX_CMD_LEN - 1)
        len = MAX_CMD_LEN - 1;
    /* skip leading spaces. */
    while (*body == ' ')
        body++, len--;

    /* extract from the msg body the cmd string, and append \0 */
    char cmdStr[MAX_CMD_LEN];
    memcpy(cmdStr, body, len);
    cmdStr[len] = '\0';
    string cmd(cmdStr);

    ANET_LOG(INFO, "Recieve cmd: %s", cmdStr);
    ostringstream outStream(ostringstream::out);
    int rc = cmdTable.ExecuteCmd(cmd, outStream);

    /* we need to include the final \0 in the packet body .*/
    int bufLen = outStream.str().length() + 1;
    if (rc >= 0) {
        /* command finished. */
        if (bufLen > 0)
            advPacket->setBody(outStream.str().c_str(), bufLen);
        else
            advPacket->setBody(NULL, 0);

        advPacket->setPcode(E_OK);
        advPacket->markAdvancePacket();
    } else {
        /* command does not finish, return error.*/
        advPacket->setPcode(E_FAILED);
        advPacket->markAdvancePacket();
        advPacket->setBody(outStream.str().c_str(), bufLen);
    }

    rc = connection->postPacket(advPacket);
    if (rc) {
        ANET_LOG(INFO, "AdminServer send response, length: %d", bufLen);
    } else {
        ANET_LOG(ERROR, "AdminServer post packet failed!");
    }
    return IPacketHandler::FREE_CHANNEL;
}

END_ANET_NS();
