/*
 * Copyright 2014-present Alibaba Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
#include "aios/network/anet/adminserver.h"
#include "aios/network/anet/addrspec.h"
#include "aios/network/anet/stats.h"
#include "aios/network/anet/log.h"
#include <sys/types.h>
#include <stdio.h>
#include <string.h>
#include <syscall.h>
#include <unistd.h>
#include <iosfwd>

#include "aios/network/anet/admincmds.h"
#include "aios/network/anet/anet.h"
#include "aios/network/anet/connection.h"
#include "aios/network/anet/controlpacket.h"
#include "aios/network/anet/defaultpacketstreamer.h"
#include "aios/network/anet/ilogger.h"
#include "aios/network/anet/iocomponent.h"
#include "aios/network/anet/packet.h"
#include "aios/network/anet/thread.h"

using namespace std;
BEGIN_ANET_NS();

pid_t gettid()
{
    return syscall(SYS_gettid);
}

void AdminServer::runInThread()
{
    _threadCreated = true;
    _thread.start(this, NULL);
}

void AdminServer::run(Thread *thread, void *arg) 
{
    start(); 
}

void AdminServer::start() 
{

    AdvanceDefaultPacketFactory factory;
    DefaultPacketStreamer streamer(&factory);
    /* remember if we create domain socket file to listen. */
    bool sockFileExist = false;
    char path[MAX_PATH_LEN];
    char spec[MAX_PATH_LEN];

    _pid = getpid();

    if (_spec == "") 
    {
        snprintf(path, MAX_PATH_LEN, "%s%s%d", DOMAIN_SOCK_PATH, 
                 ADMIN_FILE_PREFIX, getpid());
        path[MAX_PATH_LEN - 1] = '\0';
        snprintf(spec, MAX_PATH_LEN, "%s%s", "unixstream:",path);
        spec[MAX_PATH_LEN - 1] = '\0';
        _spec.assign(spec);
        sockFileExist = true;
    }

    IOComponent *ioc = _transport.listen(_spec.c_str(), &streamer, this);
    if (ioc == NULL) 
    {
        ANET_LOG(ERROR, "listen error.");
        return;
    }
    ANET_LOG(INFO, "AdminServer(%s) started.", _spec.c_str());
    _transport.run();
    ANET_LOG(INFO, "AdminServer(%s) Quiting...", _spec.c_str());
    ANET_GLOBAL_STAT.log();
    ioc->close();
    ioc->subRef();
    /* clean up domain socket file if it is generated by us. */
    if (sockFileExist)
    {
        unlink(path);
    }
}

IPacketHandler::HPRetCode
AdminServer::handlePacket(Connection *connection, Packet *packet) 
{
    if (! packet->isRegularPacket()) 
    {
        ANET_LOG(WARN, "=> ControlPacket: %d, What: %s", 
                 ((ControlPacket*)packet)->getCommand(), 
                 ((ControlPacket*)packet)->what());
        packet->free();
        return IPacketHandler::FREE_CHANNEL;
    }

    /* extracting command string from message body. */
    AdvanceDefaultPacket *advPacket = dynamic_cast<AdvanceDefaultPacket *>(packet);
    char *body = advPacket->getBody();
    int len = advPacket->getBodyLen();

    if (len > MAX_CMD_LEN -1 ) len = MAX_CMD_LEN - 1;
    /* skip leading spaces. */
    while (*body == ' ') body++, len--;

    /* extract from the msg body the cmd string, and append \0 */   
    char cmdStr[MAX_CMD_LEN];
    memcpy(cmdStr, body, len);
    cmdStr[len] = '\0';
    string cmd(cmdStr);

    ANET_LOG(INFO, "Recieve cmd: %s", cmdStr);
    ostringstream outStream(ostringstream::out);
    int rc = cmdTable.ExecuteCmd(cmd, outStream);

    /* we need to include the final \0 in the packet body .*/
    int bufLen = outStream.str().length() + 1;
    if (rc >= 0)
    {
        /* command finished. */
        if (bufLen > 0) advPacket->setBody(outStream.str().c_str(), bufLen);
        else advPacket->setBody(NULL,0);

        advPacket->setPcode(E_OK);
        advPacket->markAdvancePacket();
    }
    else
    {
        /* command does not finish, return error.*/
        advPacket->setPcode(E_FAILED);
        advPacket->markAdvancePacket();
        advPacket->setBody(outStream.str().c_str(), bufLen);
    }

    rc = connection->postPacket(advPacket);
    if (rc) {
        ANET_LOG(INFO, "AdminServer send response, length: %d", bufLen);
    } else {
        ANET_LOG(ERROR, "AdminServer post packet failed!");
    }
    return IPacketHandler::FREE_CHANNEL;
}

END_ANET_NS();    
